= The Duct Framework
James Reeves
{docdate}
:doctype: book
:encoding: UTF-8
:lang: en
:source-highlighter: coderay
:sectnums:
:toc: left

== Introduction

Duct is a framework for developing server-side applications in the
https://clojure.org[Clojure] programming language.

Duct does not rely on a project template; the skeleton of a Duct
application is defined by an immutable data structure. This structure
can then be queried or modified in ways that would be difficult with a
more traditional framework.

While Duct has more general use cases, it's particularly well-suited for
writing web applications. This documentation will take you through
Duct's setup and operation, using a web application as an example
project.

WARNING: This documentation assumes knowledge of Clojure.

== Setup

This section will cover setting up a new Duct project. You'll first need
to ensure that the
https://clojure.org/guides/install_clojure[Clojure CLI is installed].
You can check this by running the `clojure` command.

[,shell]
----
$ clojure --version
Clojure CLI version 1.12.0.1479
----

Next, create a project directory. For the purposes of this example,
we'll call the project `tutorial`.

[,shell]
----
$ mkdir tutorial && cd tutorial
----

The Clojure CLI looks for a file called `deps.edn`. To use Duct, we need
to add the https://github.com/duct-framework/main[Duct Main] tool as a
dependency, and setup an alias to execute it.

To achieve this, create a new `deps.edn` file with the following
content:

[,clojure]
----
{:deps {org.duct-framework/main {:mvn/version "0.1.0"}}
 :aliases {:duct {:main-opts ["-m" "duct.main"]}}}
----

Duct can now be run by invoking the `:duct` alias.

[,shell]
----
$ clojure -M:duct
Usage:
	clojure -M:duct [--main | --repl]
Options:
  -c, --cider              Start an NREPL server with CIDER middleware
      --init               Create a blank duct.edn config file
  -p, --profiles PROFILES  A concatenated list of profile keys
  -n, --nrepl              Start an NREPL server
  -m, --main               Start the application
  -r, --repl               Start a command-line REPL
  -s, --show               Print out the expanded configuration and exit
  -v, --verbose            Enable verbose logging
  -h, --help               Print this help message and exit
----

We'll be using this command a lot, so it's highly recommended that you
also create an shell alias. In a POSIX shell such as Bash, this can be
done using the `alias` command.

[,shell]
----
$ alias duct="clojure -M:duct"
----

For the rest of this documentation, we'll assume that this shell alias
has been defined.

The final step of the setup process is to create a `duct.edn` file. This
contains the data structure that defines your Duct application. The
Duct Main tool has a flag to generate a minimal configuration file for
us.

[,shell]
----
$ duct --init
Created duct.edn
----

This will create a file, `duct.edn` with the content:

[,clojure]
----
{:system {}}
----

== Fundamentals

This section will introduce the fundamentals of Duct's design and
implement a minimal '`Hello World`' application. While it may be
tempting to skip ahead, a sound understanding of how to use Duct will
make later sections easier to follow.

=== Hello World

As mentioned previously, Duct uses a file, `duct.edn`, to define the
structure of your application. We'll begin by adding a new component
key to the system:

[,clojure]
----
{:system
 {:tutorial.print/hello {}}}
----

If we try running Duct, it will complain about a missing namespace.

[,shell]
----
$ duct --main
✓ Initiating system...
Execution error (IllegalArgumentException) at integrant.core/eval1191$fn (core.cljc:490).
No such namespace: tutorial.print
----

Duct is searching for a definition for the component, but not finding
anything. This is unsurprising, as we haven't written any code yet.
Let's fix this.

First we'll create the directories.

[,shell]
----
mkdir -p src/tutorial
----

Then a minimal Clojure file at: `src/tutorial/print.clj`.

[,clojure]
----
(ns tutorial.print)

(defn hello [_options]
  (println "Hello World"))
----

Now if we try to run the application, we get the expected output.

[,shell]
----
$ duct --main
✓ Initiating system...
Hello World
----

Congratulations on your first Duct application!

=== Component Options

One advantage of having a configuration file is that we can customize
the behavior of components. Let's change our `hello` function to take
a `:name` option.

[,clojure]
----
(ns tutorial.print)

(defn hello [{:keys [name]}]
  (println "Hello" name))
----

Now that `hello` expects an option, we'll need to add it to the
`duct.edn` file.

[,clojure]
----
{:system
 {:tutorial.print/hello {:name "World"}}}
----

Naturally this produces the same result as before when we run the
application.

[,shell]
----
$ duct --main
✓ Initiating system...
Hello World
----

=== Variables

Sometimes we want to supply options from an external source, such as an
environment variable or command line option. Duct allows variables, or
*vars*, to be defined in the `duct.edn` configuration.

Let's add a var to our configuration file.

[,clojure]
----
{:vars
 {name {:arg name, :env NAME, :type :str, :default "World"
        :doc "The name of the person to greet"}}
 :system
 {:tutorial.print/hello {:name #ig/var name}}}
----

This defines a var called `name` with two sources. In order of priority:

. A command-line argument `--name` (set via `:arg`)
. An environment variable `$NAME` (set via `:env`)

This value can be inserted into the system map with the `#ig/var` data
reader. If the variable has no value, an error will be raised, so it's a
good idea to set a default value using the `:default` key.

NOTE: The '`ig`' in `#ig/var` stands for _Integrant_. This is the
library that Duct relies on to turn configurations into running
applications.

The `:type` of a var determines the data type it should be coerced into.
Duct supports three types natively: `:str`, `:int` and `:float`. The
default type when the key is omitted is `:str`.

Duct integrates these vars into its help message. The `:doc` option
specifies a description of the var.

[,shell,highlight=13]
----
$ duct --help
Usage:
	clojure -M:duct [--main | --repl]
Options:
  -c, --cider              Start an NREPL server with CIDER middleware
      --init               Create a blank duct.edn config file
  -p, --profiles PROFILES  A concatenated list of profile keys
  -n, --nrepl              Start an NREPL server
  -m, --main               Start the application
  -r, --repl               Start a command-line REPL
  -s, --show               Print out the expanded configuration and exit
  -v, --verbose            Enable verbose logging
  -h, --help               Print this help message and exit
      --name NAME          The name of the person to greet
----

The var can then be specified at the command line to produce different
results.

[,shell]
----
$ duct --main --name=Clojurian
✓ Initiating system...
Hello Clojurian

$ NAME=Clojurist duct --main
✓ Initiating system...
Hello Clojurist
----
